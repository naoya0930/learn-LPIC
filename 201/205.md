# 高度なストレージ管理
### RAID
- Redundant Arrays of Inexpensice Disks
- ソフトウェアRAID
  - mdadm(Multi deviceドライバ)で設定・監視・再構築
  - モジュールによって管理されている
- ハードウェアRAID
  - RAID専用のチップを組み込む
  - PCIeチップをPCに差し込んで，そこにディスク接続
  - マザーボードにチップが入っていることもある
- `/dev/md0`とか名前が付けられる．
  - UUIDは割り当てられない
#### RAIDの種類
- LVMは一段後の工程．RAID+LVMという構成になる．
  - 実際の所，併用する可能性は低い
- RAID0...ストライピング
  - 複数のディスクに分散してデータ書き込み
  - 1台のディスクのように扱う
  - 冗長性を担保しない
- RAID1...ミラーリング
  - 同じデータを複数保存する
  - 2台から構築可能
- RAID4...ストライピング+パリティ
  - 3台以上の構成に対して実現可能
  - 1台をパリティ情報を保存する専用ディスクにする
- RAID5...ストライピング+パリティ
  - 3台以上の構成に対して実現可能
  - 自身以外のディスクのパリティ情報を保存する領域を自身のディスクに設ける
  - 効率はRAID4と同じ
- RAID6...ダブルパリティ
  - 4台以上の構成に対して実現可能
  - 2台の同時故障に対応できるようにパリティ領域を構成する
- RAID10..ミラーのストライピング(1+0)
  - ミラー構成にした後に，ストライピングするように構成
#### パリティ・チェックサム
- 2台のデータのXORをパリティディスクに書き込むイメージ
- RAID4であれば，N/(N-1) の容量が必要になる
- RAID6の場合は，N/(N-2)の容量が必要になる．
- チェックサム機能は無いので，ビット単位で復元できるわけではない．

#### RAIDにおけるスペアデバイス
- それぞれのRAIDにおいて、構成時にスペアデバイスという概念も同時に入れる
- RAID1など構成要素全てがマスタで、完全同期して書き込んでいく
  - ここからオプションとして待機ストレージ(spareと呼ぶ)を設定することができ、障害発生時に自動昇格する
- ☆ リードレプリカと異なり、障害発生時に初めて同期を開始する
- 
#### 【復讐】パーティションID
- そのパーティションを何に使用するか識別するID
- MBRの場合
  - `fdisk -l` で表示
  - HEX Codeとか読んだりする
- GPTの場合
  - `gdisk -l`で表示
  - GUID(Globally Unique Identifier)とか呼ぶ
    - 32桁16進数
### RAIDの運用
- RAID IDが割り当てられている
- MBRのヘックスコード
  - ★ `FD`...Linux RAID Autodetect
    - ほとんどの場合，RAIDであることはこちら
  - `DE`...Dell Utility
    - Dell製のPCで使用することがある
- GPTのGUID
  - Linux RAID
    - A19D880F-05FC-4D3B-A006-743F0EE14D02
  - Apple RAID
    - 52414944-4F43-11AA-AA11-00306543ECAC
  - LVM
    - E6D6D379-F507-44C2-A23C-238F2A3AD000

#### RAIDの作成・管理
- mdadmを使用する（multi device administかな？）
  - 生ディスク(sda)、パーティション(sdaX)、RAIDデバイス(mdX)を対象に扱う
  - フォーマットする前に実行すること。
- モードが3つある
  - 作成（クリエイトモード）`--create`,`-C`
  - 操作（マネージモード）`--manage`
  - そのほか(miscモード)`--misc`
- モード別オプション
  - 作成 `mdadm -C [new devfile] {オプション}`
    - オプション
      - -a...必要であればデバイスファイルを自動的に作成
      - -c {size}...チャンクサイズを指定する(KB)
      - -l,--level={level}...RAIDレベルを指定する
      - -n,--raid-devices={num} {dev_file}...アクティブな構成のデバイス数を指定する
      - -x,--spare-devices={num} {dev_file}...スペアデバイスの数を指定する
  - 操作 `mdadm --manage {option}`
    - オプション
      - -a,--add {dev} {mddev}...構成デバイスを追加する
      - -r,--remove {dev} {mddev}...構成デバイスを削除する
      - -f,--fall {md_dev} {mdの構成dev}...構成デイバスに不良タグをつける
  - そのほか `mdadm --misc {option} [md_device]`
    - miscはつけなくてもよい
    - オプション
      - -Q,--query...RAIDの状態を確認する
      - -D,--detail...RAIDの詳細な状態を表示
      - -E,--examine...構成デバイスの状態を表示
      - --readonly...mdデバイスを読み取り専用にする
      - --readwrite...mdデバイスを読み画期可能にする
      - --stop... RAIDアレイを停止する
      - --stop --scan...全てのRAIDを停止する
#### mdadmコマンド補足
- チャンクサイズ...分散する対象のデータサイズ


#### `/proc/mdstat`
- RAID構成状態の確認

#### RAIDの起動と専門用語
- アセンブル(assenble)
  - ブート時と手動コマンド`madam -assemble`実行時のステップ
  - `/etc/mdadm/mdadm.conf`やsuperblockを参照してRAIDデバイスを作成する
  - ブート時に関しては`initramfs`が実行してくれる
- チェック(check,resync,rebuild)
  - RAID起動時と、手動コマンド実行時、以上発生時のステップ
  - RAIDメンバ間のデータの整合性を確認、修復
    - check...RAIDの整合性の確認を実施
    - resync...RAID 1/10でミラー同期を実行
    - rebuild...RAID 5/6で欠落ブロックを修復
- superblock
  - RAID要素の先頭もしくは末尾に対して書き込まれる
  - UUID...RAIDアレイのユニークID
  - RAIDレベル
  - メンバ番号...このディスクがそのRAIDで何番目か？
  - デバイス状態...active/spare/failed など
  - データオフセット...RAID内でのデータ配置位置
  - メタデータバージョン...mdadm.confで参照されるバージョン
#### 構成の保存`/etc/mdadm/mdadm.conf`
- 起動の自動管理ができる
  - ARRAY {md_dev} {mdadm_metadata} {構成要素のUUID...}
- ☆ RAIDの構成を変更できるわけではない
  - ディスクのsuperblockに基づいて
- mdamdに参照されるものの、mdamdのバックアップぐらいにかんがえれば良い
  - `mdadm --detail --scan >> /etc/mdadm/mdamd.conf`
### LVM
- Logical Volume Manager
- 論理ボリューム管理
- 特徴
  - 一度作成作成するとサイズ変更できない
  - 別のディスクにパーティションを移動させることはできない
  - ディスクサイズを超えるパーティションは作成できない
- LVMにおける語句 
  - 物理ボリューム(PV:Physical Volume)...LVMで扱うパーティションとして扱う
  - 物理エクステント(PE:Physical Extent)...LVMでの管理最小単位(4MB程度)の物理領域。
  - 論理エクステント(LE:Logical Extent)...LVMでの管理最小単位。物理エクステントと同じ
  - ボリュームグループ(VO:Volume Group)...LVMでディスクとして扱う全パーティションの集合
  - 論理ボリューム...ボリュームグループをユーザが切り分けたもの
### LVM作成
- MBRでのパーティションタイプヘックスコードは「8e」
- GPTの場合は「E6D6D379-F507-44C2-A23C-238F2A3DF928」
### ボリュームを作成する `pvcreate`
- ブロックデバイスを物理ボリューム(PV)として初期化する
  - LVM用になり、中身を破棄する
- `pvcreate {phisical volume}`
- 対象はブロックデバイスであればなんでもいい
  - 生ディスク`/dev/sda`
  - パーティション`/dev/sdb2`
- パーティションを物理ボリュームとして扱うメリットってあるの？
  - MBRで2TBを扱う場合や、ブートディスクはLVMにしない方が良い。
    - LVMはGRUBで読めない
#### ボリュームグループを作成する`vgcreate`
- `vgcreate {vg_name} [dev1 dev2...]`
- オプション
  - -s {size}...物理エクステントの名前のサイズを指定する
#### 論理グループを区切る`lvcreate`
- `lvcreate -L {size} -n {name} {vg_name}`
- L,nは必須オプション
  - -L {size}...論理ボリュームサイズを指定
  - -n {lv_name}...論理ボリューム名を指定する
- 論理ボリュームをちょうど使い切ることはできないの？
  - 全然できる。ただし、エクステントで割り切れる値にしようね
  - `lvcreate -l 100%FREE -n lv_data vg0`
- ファイルシステムはこの上に作成する。
  - `mke2fs /dev/{lg_name}/{lv_name}` など
#### 論理グループを確認する
- `lvscan`
### LVMの管理
#### 物理ボリュームの状態を表示する
- `pvdisplay {used_lv_phisical_dev}`
- phisical volumeの略なので、LVM用途に使用されていなければならない
- 表示ステータス
  - PV NAME...物理パーティション/ディスク名
  - VG NAME...所属しているVolume Group名
  - PV Size...ストレージの総合サイズと、利用量
  - Allocatable...LVMに割り当てされているか？
    - --allocatableというオプションがあり、これに対して、YES/NOを指定することができる
  - PE Size...物理エクステントサイズ数
  - Total PE...そのストレージで何個のPEが作られるか
  - Free PE...未使用PE
  - Allocated PE...使用済みPE
  - PVUUID...物理ボリュームのUUID
    - 物理ディスクと物理ボリュームで異なるUUIDが設定されている

### LVM関連コマンド
#### ボリュームグループの拡張
- `vgextend {vg_name} {adding_pv_name}`
#### 物理ボリュームを移動する
- ディスクの交換などで物理ボリュームを別のpvに移動させる
- `pvmove {pv_name1} {pv_name2}`
- 当然同じVG上で実行するコマンド
#### ボリュームグループの縮小
- `vgreduce {vg_name} {pv_name}`
- vgに所属しているpvを削除
- 削除前に空にしておく(pvmoveしておく必要がある)
#### 物理ボリュームの削除
- `pvremove {pv_name}`
  - LVGメタデータを初期化する
    - PVに割り当てられていたUUID
    - 所属しているVG情報
  - ファイルシステムのフォーマットは残る
#### ボリュームグループの情報表示
- `vgdisplay {vg_name}`
- 主な表示内容
  - VG Name...ボリュームグループ名
  - SystemID
  - Format...LVMのバージョン現行はLVM2
  - Cur LV...ボリュームグループ内の論理ボリュームの数
  - Cur PV...物理ボリュームの数
  - VG Size... ボリュームグループのサイズ
  - PE Size...物理エクステントのサイズ
  - Total PE...論理ボリュームのエクステント総量
  - Alloc PE /Size...割当済みエクステント個数/MB
  - Free PE/ Size 空きエクステント個数/MB
  - VG UUID
#### 論理ボリュームの状態表示
- 論理ボリュームは/dev/論理ボリュームグループ/論路ボリューム名となる
- `lvdisplay {/dev/{lg_name}/{lv_name}`
- 主な表示内容
  - LV Path...論理ボリュームのパス
  - LV Name...論理ボリュームの名前
  - VG Name...所属しているボリュームグループ名
  - LV UUID
  - LV Size...論理ボリュームのサイズ(MB)
  - Current LE...論理エクステントの数
#### 論理ボリュームの拡張
- ボリュームグループの空き容量を既存の論理ボリューム(lv)に割り当てる
- `lvextend -L {size[MB/GB/etc]} {lv}`
- 再起動は必要ない。
- 伸縮性がないファイルシステムでは、認識できない場合がある
  - 伸縮性なし...FAT16,FAT32などなど
  - 伸縮性あり...ext4,XFS
#### ext論理グループの拡張`resize2fs`
- `resize2fs {lvname}`
- オプションを指定する必要はない
- ext系のファイルシステムの認識領域を広げる
- ファイルシステムの整合性は`e2fsck-f {lv_name}`を使用してチェックしておくこと
#### xfs論理グループの拡張`xfs_growfs`
- `xfs_grow {lvname}`

#### 論理ボリュームの削除
- `lvremove {lv_name}`


#### スナップショットを作る
- `lvcreate -s -L {size} -n {snap_name} {lvnmae}`
- lvcreateに-sオプションを入れる
- Copy-on-Write方式で動作
  - スナップショット領域には、実行直後の変更差分が保存されていく
  - 容量がいっぱいになれば、追従しなくなる。（LVの変更を保存できなかったので、ほぼデータとしての意味がなくなる）
- 普通は数時間、数分程度の保管にしか利用しない
  - なのでLVに対して数%、20%程度だけ割り当てれば良い
- バックアップを作成する場合はスナップショットは不要
- タイムインスナップはDBの機能なのでこれとは異なる。
  - ストレージの特有機能として扱う
### LVM Thin Pool
- 必要な分だけ物理容量の値を消費する仕組み
- LVMのスペック以上のストレージ容量を作成可能
- ただし、枯渇するとLVMが破損する
- 普通のLVMとも共存できる

### LVM関連コマンドまとめ
- 物理ボリューム関連
  - pvcreate
  - pcdisplay
  - pvmove
  - pvremove
  - pvscan...PVの検索
  - pvs...PVの情報を出力する 
- ボリュームグループ関連
  - vgcreate
  - vgchange
  - vgdisplay
  - vgextend
  - vgreduce
  - vgremove
  - vgimport
  - vgexport
  - vgmerge...vg同士の統合
  - vgrename
  - vgscan
  - vgs
- 論理ボリューム関連
  - lvcreate...論理ボリュームの作成、-sでスナップショット作成
  - lvdisplay
  - lvextend
  - lvreduce
  - lvremove
  - lvrename
  - lvscan
  - lvs

## 記憶装置へのアクセス
#### 主なデバイスファイル
- /dev/hda...IDEプライマリマスタのドライブ
- /dev/hdb...IDEプライマリスレーブのドライブ
- /dev/hdc...IDEセカンダリマスタのドライブ
- /dev/hdd...IDEセカンダリスレーブのドライブ
  - Integratd Drive Electronicドライブの略
  - ATAやPATAとか呼ばれる
- /dev/sda...SCSI/SATA/USB/IEEE1394デバイス
- /dev/sbb
- /dev/sbc

- /dev/sr0...SCSI/SATA/USB/CD/DVD
- /dev/sr1...SCSI/SATA/USB/CD/DVD

- dev/st0..テープドライブ

#### ハードディスクの管理
- IDE(ATA)
- SATA(Serial ATA)
- SCSI
- SAS(Serial Attached SCSI)
- USB
- IEEE1394
  - Fire Wire
  - i.LINK
  - DV端子　とか呼ばれる

#### IDE転送モード
- PIOモード
  - Programmed I/O
  - ハードディスクに直接命令してデータを転送する
- DMAモード
  - Direct Memory Access
  - 専用のコントローラチップがデータ転送を管理
  - 今はこちらが主流
- Ultra DMA
  - DMAの拡張
  - より高速で動作する
  - BIOS側のチップセットが対応している必要がある
#### ハードディスクのパラメータを確認する `hdparam`
- `hdparm {option} {dev_file}`
- オプション
  - -i...ハードディスクの詳細情報を表示
  - -c0...32bit IOモードをオフにする
  - -c1...32bit IOモードを有効にする
  - -c3...32bit IOモードを有効、同期シーケンスもオンにする
  - -d0...DMAモードを無効にする
  - -d1...DMAモードを有効にする
  - -t...バッファキャッシュを使わずに読み込みを計測
  - -T...バッファキャッシュの読み込み速度をテスト
- 32bit IOモードは本来16itのものを32bitに拡張するもの
- 表示項目
  - using_dma =1 ... DMAが有効か否か

#### SCSI/SATA/USBに対するパラメータ確認`sdparm`
- SCSi diskの略
- こちらはハードディスクドライブへの制御もできる

### SSDの管理
- Solited State Drive
- システムの都合上書き換えの上限がある
  - NAND回路が劣化していく
  - 下記を使用して、可能な限り長く利用できるようにしていく
    - Wear Leveling...書き込み領域の分散化
    - ECC...誤り訂正
- 削除する場合は、ブロックデータの削除は実施しない
  - 実際は削除フラグをつけるだけ
- 明示的に削除を実施するには、Trimを使用する
  - コマンド名ではなく、削除可能な領域のこと
- `hdparm - I /dev/sda | grep TRIM`で検索可能
#### Ttimの実行
- `fstrim -v /`


#### iSCSI
- Internet Small Computer System Interface
- SAN(Storage Area Network)のためのシステム
  - SANには2種類の方式がある
  - Fibre Channel SAN
    - これはFCPプロトコルで動作する
    - 光ケーブルだが、イーサネットではない（LC光/SC光）
  - iCSI-SAN
    - iSCSIプロトコルで動作する
    - サーバブロックのIOをTCP/IPでカプセル化して送受信する
- 関連用語
  - ターゲット...iSCSIストレージ
  - イニシエータ...iSCSIクライアントのこと。ホストと言われればこちら
  - LUN...Logical Unit Number。 ストレージ内の論理ドライブ番号(/dev/sda,imageファイルなど)
  - HBA...Host BUS Adapter。ネットワークにおけるインタフェースに相当するアダプタ
  - WWN...World Wide Name。イーサネットにおけるMACアドレスに相当する64bit 識別ナンバー
  - iSCSI Qualified Name(IQN)...ターゲットが持つ固有識別子。LUN内でユニーク
  - バックストア...ターゲット側に提供するストレージ領域
- 
#### iSCSI構築

#### iSCSI管理コマンド`targetcli`
- ISCSIターゲットを階層化して管理している
- ファイルシステムではないが、lsやcdが使用可能
- 例
  - /blockstores...イニシエータからどう見えるか？それぞれiqnとの対応が必要
    - /block
    - /fileio
    - /ramdisk
  - /iscsi
    - /iqn.XXX...アクセスできるイニシエータや、IQNがどのLUNに割り当たっているのか定義
      - /tpq1
        - /luns/...このターゲットが提供するLUNの一覧
        - /acls/...アクセス許可イニシエータリスト
        - /portals/...TGPがバインドするネットワークポート（IPとポート）
#### ターゲット側の構築
- 1. 構築の開始
  - target cliというものを使用する
    - `yum install targetcli`
  - デーモン形式なのでsystemctlで実行
    - `systemctl start target.service`
    - systemdの起動構成のtargetではない。
  - 対話形式での実行も可能
- 2. バックストア移動（イニシエータ側でどう見えるか？）
  - `cd /blockstores/{type}`で移動可能
  - 様式
    - block...物理ディスク、パーティションとして使う
    - flleio...ファイルを仮想ディスクとして使用
    - ramdisk...RAM上のメモリを仮想ディスクとして使用
    - pscsi...物理SCSIデバイスをパススルー
- 3. バックストアの作成
  - 任意のバックストアタイプ内で
  - `create name=XXX dev=/dev/XXXvg/lv01`
- 3. iQNの作成
  - `/isci/`配下で以下を実行
  - `create {IQN}`
- 4. IQNとバックストアを紐付け
  - /iscsi/{iqn}/tpg1/luns/ 配下に移動して以下を実行
  - `create /backstore/block/XXX`...XXXというIQNをバックストア名で公開
  - ★ createコマンドは実行する場所で意味が異なる
- 5. アクセス権の設定
  - /iscsi/{iqn}/tpg1/acls/ 配下に移動して以下を実行
  - `create {イニシエータiqn}`


#### イニシエータ側の構築
- `yum install iscsi-initiator-utils`
- これもデーモン形式なので起動が必要
  - `systemctl start iscsid.service`
- 以下のコマンドでイニシエータとしてのIQNを確認可能
  - `cat /etc/isici/initiatoename.iscsi`
#### イニシエータでターゲットに接続する　`iscsiadm`
- 接続の確認
  - `iscsiadm -m discovery -t sendtargets -p {ip}`
  - ip先で構築されている接続可能なiscsiターゲットのIQNが表示される
- ログインを実施する
  - `iscsadm -m node --login`
    - セッションの確率、LUN情報の取得、ブロックデバイスの準備のことを指す
    - 

# セキュリティ

### スーパーサーバ
- ポートに対して監視を実行
  - カーネル上にスーパサーバのサービス名でリソースを確保
  - ポートへのリクエストを検知してソケットを渡す
- TCP Wrapperによってアクセス制御を集中管理をしている
  - FTP(21),Telnet(23)などのプロトコルはこれを使用する傾向にある
- 例
  - ined,xinetd(読み方はアイネットデーモンかな？)

- デメリット
  - 応答が遅れる
  - クライアントからの要求にすぐに答えるにはサーバ自身が要求を監視すべき
    - これをスタンドアロンという
    - Web(HTTP,HTTPS)はこのしくみでTCPwrapperを使用していない


### xinetdの設定
- 設定ファイルが2つある
#### `/etc/xinetd.conf`
- `defaluts{`
- `instances=60`... 各サービスの最大デーモン数
- `log_type=SYSLOG authpriv`...ログのファシリティ、xinetd自身のログの設定
- `log_on_success=HOST PID`...接続元IPと起動したPID
- `log_on_filure=HOST`...接続元PID
- `cps=25 30`...connect per second,1sに25アクセス以上来ると、30sサービスを休止させる
- `}`
- `includedir /etc/xined.d`...設定ファイルのディレクトリ
#### `/etc/xinetd.d/*`
- telnetやftpなど、使用するプロトコルごとにファイルが存在する
  - これをサービスと呼ぶ(プロトコル+ポート番号がセット)
- `service telnet{` ...プロトコル名
- `disable=no`...サービスの有効/無効
- `socket_type=stream`...TCP(stream)/UDP(dgram)
- `wait=no`
  - yes...1クライアントを処理するまで並列処理しない
  - no...複数クライアントとの通信を許可(TCPはno)
- `user=root`...サービス起動時に切り替えるユーザ
  - プロセスそのものの実行ユーザ
- `server=/usr/sbin/in.telnetd`...起動するサービス名
- `log_on_success+= USERID HOST PID`...接続成功時にログを書き込む情報
- `log_on_failure+=USERID HOST`...接続失敗時に書き込むログの情報
- `cps=25 30`...1s間に25回接続されると30s無効化(DoS対策)
- `}`
#### 変更した設定を再起動する
- `/etc/init.d/xinited restart`

### systemdによるサービスの監視
- `systemctl start xxx.socket`
- 基本的に1ソケットに対して1ソケットファイルを持つ
- いくつかをまとめてサービスにはしていない
- 例：`/etc/systemd/system/telnet.socket`
- `[Unit]`
- `Description={description_comment}`
- `[Socket]`
- `ListenStream=10023`
- `Accept=yes`...1アクセスごとにサービスが起動する
- `[install]`
- `WantedBy=socket.target`


### SystemdファイルのWantedBy
- {そのターゲットファイル名}.wantsも一緒に起動する
  - wantsファイルはシンボリックファイルが入っていることが多い


### TCP Wrapper
- tcpd...tcp wrapを管理するサービス
  - システムコールを実行するデーモンではない
  - サービスごとにTCPすることを拒否することができる
- Firewallを持たないTCPサービスにおいて用いられるフィルタ機能
- 接続毎にファイルを参照するため、再起動の必要がない
- IPもしくはドメイン名によってアクセス制限を実行する
- `libwrap`というデーモン経由で設定ファイルを読み出す
- つまりこのライブラリを参照しないサービスには関係ない話
  - Openssh、POP/IMAPはlibwrapを使用している
- 設定ファイル
  - `/etc/hosts.allow`
    - ここに入っていれば、denyに書かれていても通信は許可する
  - `/etc/hosts.deny`
    - allowにもdenyにも書かれていない通信は許可する
- 設定ファイルの書式
  - IPやホスト名を指定して記載する
    - `sshd: .sample.jp`
    - `telnet: 192.`
  - `ALL:{IP|host}`,`{service}:ALL`...全てのサービス、ホスト
  - `X EXCEPT Y`...Y以外のX
  - `LOCAL`...「.」を含まないホスト
    - ローカルネットワークのセグメントを許可
  - `PARANOID`...IPとホストが一致するか、逆引き正引きして検証する

### 開いているポートの確認, `netstat`,`ss`,`lsof`
#### `netstat [option]`
- オプション
  - `-a`...全てのソケットを表示
  - `-c`...状況を1sごとにおいかける
  - `-i`...インタフェースの状態を表示
  - `-n`...アドレスやポートを数値で表示
  - `-p`...PIDとプロセス名を表示
  - `-r`...ルーティングテーブルを表示
  - `-t`...TCPポートを表示
  - `-u`...UDPポートを表示
- ※ ホストはDNSによって解決するため、DNSが停止していると戻らない
  - -nを使用すれば、DNSを使用しない
#### `ss`
- netstatより新しいコマンド
- ほとんどnetstatと互換性を持つ
- netstatは`/proc/net/*`を見るが、こちらは`netlink.socket`を見る
#### `lsof`
- これは本来はネットワークを見るコマンドではない
- 仮想ファイルを含めた全てのファイルを参照しているプロセスを表示
  - sshdが22番ポートを参照していたり、nginxが80番を参照しているのがわかる
- オプション
  - `-i`...開いているポートの情報を表示
  - `-i:{port_num}`...指定したポート番号が使われている通信を表示

### 開いているポートを確認する `nmap`,`fuser`
#### `nmap`
- よくポートスキャンで使用されるコマンド
- リモートホストで開いているポートを確認でキル
- `nmap {host_name}`
#### `fuser`
- file_userコマンド
  - `lsof`と同様にファイルを開いているユーザを見るコマンド
- ネームスペースが到達可能なプロセスを戻す
- Linuxにおけるネームスペース
  - PID namespace
  - Mount NameSpace
  - Network Namespace 
- ネームスペースの要素
  - ネットワークデバイス
  - IPアドレス
  - ルーティングテーブル
  - firewall
  - ARP
  - ソケット
- 主にはポートを使用しているプロセスを表示するために使用
  - 仕組みとしては `cat /proc/net/tcp`を参照
    - 16進数でポートファイルを使用しているinodeが書いてる仮想ファイル
- 使い方
  - `fuser -n tcp 8080`
    - （コマンドを実行しているnamespaceで）ポートのプロセスを表示
  - `fuser -k 8080/tcp`
    - ポートを利用しているプロセスを削除
  - `fuser -{SIGNAL} -n tcp 80`
    - ポートを利用しているプロセスにシグナル

### SUIDによる権限昇格
- SUIDが設定されているファイルを検索する
  - `find / -perm -u+s -ls`
  - findコマンドによってルートは以下の全てに関して権限を調査
  - `-ls`形式で出力する
### パスワード管理 `chage`コマンド
- change ageの略
- オプション
  - `chage -l {user}`...パスワードもしくはアカウントの有効期限を表示
  - `chage -m {day} {user}`...パスワード変更の最低日数を設定
  - `chage -M {day} {user`...パスワード変更の最大日数を設定
  - `chage -d {date} {user}`...パスワードの最終更新日を設定する
  - `chage -W {day} {user}`... パスワードの有効期限切れの警告が有効期限切れの何日前から
  - `chage -l {day} {user}`...有効期限が切れてから，何日でロックするか
  - `chage -E {date}`...アカウントを無効化する日付
- `chage {user}`...で対話モードの設定が可能
- `/etc/shadow`のファイルを書き換えている

## ログイン関連
### 常にrootでログインする
- `touch /etc/nologin`
  - このファイルを作成すると一般アカウントでログイン不可になる
- `usermod -s /sbin/nologin {user}`
  - /sbin/nologin...疑似シェル．シェルとして呼び出されると無効化する
- `/etc/passwd`を直接変更してもよい
  - {username}:{passward}:PID:GID:{コメント}:{homedir}:{shell}
  - 最後のシェルを/sbin/nologinにする

### ユーザ切り替え `su`
- `su -{user}`
  - シェル変数をリセットしてユーザを切り替える
  - 新しいプロセスが実行されるため，PIDも変わる
- `su {user}`
  - シェル変数をそのままにユーザを切り替える
  - こちらもpidを変更
- `su`，`su -`
  - root権限でシェルを起動
### 管理者権限でユーザにコマンドを許可する`sudo`
- rootではなく，そのユーザのパスワードでコマンドを実行する
- 利用設定
  - rootユーザで `visudo`を実行
  - `/etc/sudoers`が開かれる
  - ここに許可記載されていれば，実行可能．書かれていなければ実行不可
- オプション
  - `sudo -l`...許可されているコマンドを表示
  - `sudo -i`...ルートシェルにログイン．環境変数を初期化
  - `sudo -i -u {user}`...ユーザにログイン
  - `sudo -s`...ルートシェルを起動．環境変数はそのまま
    - ホームディレクトリとか変になってるので注意
### /etc/sudoersを設定する
- `{username} {hostname}=(run_as) [option:]{command}`
- username...あるユーザ，グループやエイリアスが実行するか
- hostname...どのマシンで
- runas...誰として実行しているか(root)
  - 指定ナシならばroot
- optionに`NOPASSWD:`を入れるとユーザのパスワードなしに実行可能になる
- command...実行できるコマンド
  - パスで指定するのが基本
- `student ALL=(ALL) /sbin/shutdown`
  - studentユーザにシャットダウンコマンドを実行可能にする
- `user_g ALL=(ALL) NOPASSWD:ALL`
  - グループにパスワードなしで実行可能


### システムリソースの制限　`ulimit`
- シェル自身やシェルから起動したプロセスが起動するプロセスのリソース制限
  - DBのプロセスとカーネルの参照ファイル上限の整合性を取る
  - クラッシュ時のファイルが巨大になることを防ぐ
- オプション
  - `ulimit -a`
  - `ulimit -c {サイズ}`
    - デバック用に使用するコアファイルの最大サイズを指定
  - `ulimit -f {サイズ}`
    - シェルが生成できるファイルの最大サイズをブロック単位で指定
    - mkfsなどで指定した大きさ
  - `ulimit -n {number}`
    - 同時に開くことができるファイル最大数
  - `ulimit -u {プロセス数}`
    - 1ユーザが利用できる最大のプロセス数を指定する
  - `ulimit -v`
    - シェルとその子プロセスが利用できる最大仮想メモリのサイズを指定

# openssh
- 微妙にディストリビューションで扱えるライブラリ名が異なる
  - debian系：openssh-client,openssh-server
  - Red hat系：openssh,oepnssh-server,openssh-client
- Opensshの鍵について
  - これはopenssh設定ファイルによって，その鍵が何どんな鍵なのか知っている
- sshdはサーバ側のプロセス
#### クライアント → サーバ証明
- クライアント側で鍵を作成する
- サーバの`~/.ssh/authorized_keys`に鍵を公開鍵を配置
- クライアントからのリクエストに対して、チャレンジを発行し
- チャレンジを秘密鍵で署名
- 接続要求を署名と一緒に送る
- 署名は公開鍵によって検証されるので
- クライアントが認証される

#### サーバ → クライアント証明
- `/etc/ssh/{鍵名}`でサーバ側に置いてる
- 鍵名
  - 秘密鍵
    - ssh_host_key(RSA:1028)
    - ssh_host_dsa_key(DSA)
    - ssh_host_rsa_key(RSA:2048以上)
    - ssh_host_ecdsa_key(楕円曲線)
    - ssh_host_ed25519_key(楕円曲線)
  - 公開鍵
    - 秘密鍵.pubのファイル名になる
    - この鍵を送信してサーバ自身を証明する
    - 一度でもユーザから接続を受けると、クライアントに`~/ssh/knownhosts`に保存される
### サーバ側の設定ファイル
- `/etc/ssh/sshd_config`
  - Port...使用するポート(22)
  - Protocol...SSHのバージョン
  - HostKey...ホストの秘密鍵ファイルディレクトリ
  - PermitRootLogin...クライアントからのルートログインを許可
  - RSA_Authentication...RSA1024ログインを許可(SSH-1)
  - PubkeyAuthentication...他の公開鍵認証を許可(SSH-2)
  - AuthorizedKeyFile...
    - クライアントの公開鍵の格納ファイル名。
    - クライアントの証明も実施する場合はこの場所に配置
    - `~/.ssh/authorized_keys`のこと
  - PermitEmptyPassword
    - 空パスワードの許可
  - PasswordAuthentication
    - パスワード認証の許可
  - X11Forwarding
    - X11転送の許可
### sshを起動する
- SysVinit(RedHat)
  - `/etc/init.d/sshd shart`
- SysVinit(Devian)
  - `/etc/init.d/ssh start`
- systemctl
  - `systemctl start sshd.service`

### sshコマンド
- ssh [user@hostname]
- ssh [user@ipaddr]
- ssh [host]
  - ユーザ名は実行時のユーザ名になる
- オプション
  - `ssh -p {port番号}`
    - ポート番号を指定
  - `ssh -l {username}`
    - 接続するユーザを指定する
    - 通常は不要
  - `ssh -i {sec_file}`
    - 秘密鍵を使用してログインを簡略化する
    - 公開鍵認証

### ホスト(サーバ)認証
- 接続しているサーバが正しいか検証できる
- サーバ側が用意してあげる
  - ~/.ssh/known_hostsに
    - サーバの公開鍵をクライアントが保存
  - 接続の度に鍵検証
  - 初回には鍵を作成する
### クライアント認証
- 接続元のユーザが正しいか認証する
  - これはパスワードと同じ役割
  - 公開鍵認証によるログイン
- ユーザが鍵を用意する
  - サーバ側にクライアント側自身の公開鍵を共有
  - `~/.ssh/authorized_keys`
- 認証時には、サーバ側がチャレンジ送付
- クライアントが署名送付

### sshハンドシェイク
- サーバ認証が先に実施される
- その後、クライアント認証

### 鍵の生成 `ssh-keygen`
- `-t`...鍵の暗号方式を指定
  - rsa1...1024(v1)
  - rsa...2048以上(v2) `-b`で長さを指定できる
  - dsa
  - ecdsa
  - ed25519
- `-p`...パスフレーズを指定
- `-f {file}`...生成する鍵ファイル名を指定する
- `-R {host}`...ホストの鍵をknown_hostsから削除

### パスフレーズ
- 秘密鍵を扱う時に使用するパスワード
- 合っているか間違っているか検証しないので
  - ハードディスク上には保存しない

### ssh-keygenで作成される鍵
- v1_rsa1024なら
  - 秘密鍵...identify
  - 公開鍵...identity.pub
- v2なら
  - 秘密鍵...id_{key_type}
  - 公開鍵...id_{key_type}.pub

### 鍵の事前共有
- クライアントが共有鍵認証を実施する場合
- `scp ~/.ssh/id_dsa.pub host:pubkey`
- このあと、サーバ側で/pubkeyを~/.ssh/authorized_keysに追記
- 全ユーザ分を1ファイルで管理しているため、上書きするとまずい
- `ssh-copy-id`コマンドでこれを解消している
  - `ssh-copy-id -i {公開鍵} {user}@{ssh先ホスト名}`

# sshでできること
### scpファイルコピー
- ログインをログインを実施しない
- セッションを確立しないためホスト側が正しいか検証しない
- `scp {コピー元ファイル} {コピー先ファイル}`
  - ファイルは {ユーザ名}@hostnameで指定可能
- オプション
  - -p permissionを保持
  - -r ディレクトリを再帰的にコピー
  - ^P ポート番号を指定する
### ssh-agent
- パスフレーズを省略するクライアント用エージェント
- 1. ssh-aget bash ...バッシュを起動
- 2. ssh-add ...パスフレーズを入力
- ssh-add -l ...連携している秘密鍵を確認

### sshポートフォワーディング
- ssh -L [localport]:[remotehost]:[remoteport] [user]@[remotehost]
- localhostで受けて、remoteportに出す

### X11接続
- ssh -X {hostname}
- `/etc/ssh/sshd_config`の設定は必須
- `X11Forwarding ysed`

# GnuPG暗号化
- GNU Private Guardの略
- 公開鍵暗号を使用してファイルを暗号化、複合化、署名を実施
- 歴史的には暗号化ソフトウェアPGP(Pretty Good Privacy)の仕様
### pgp用の鍵ペアを作成
- `gpg --full-generate-key`
- 対話形式で作成が可能
  - 1. 暗号化方式
    - RSA,DSA,DSA(署名のみ),RSA(署名のみ)
  - 2. 鍵長
  - 3. 鍵の有効期限
  - 4. 鍵の識別（メールによる証跡を残す）
  - 5. パスフレーズ登録
- 保存先は`~/gnupg/`
  - 公開鍵リスト(キーリング)`pubring.gpg`
  - 秘密鍵リスト(キーリング)`secring.gpg`
- `gpg --list-keys`で参照
### 証明書失効を管理
- パスフレーズが漏れた、パスワードを消失した場合
- `gpg -o {出力失効証明ファイル} --gen-revoke {key_hash}`
  - 失効証明ファイル、.acsのasciiで書かれることが多い
    - 中身が`BEGIN PGP PUBLIC KEY BLOCK`で始まっている
  - key-hash
    - gpg --list-keysで確認可能

### ファイルを暗号化/復号する
- ここでの暗号化はパスフレーズ={共通鍵}を利用する
  - 作成した鍵は利用しない
- 暗号化
- `gpg -c {filename}`
  - `{filename}.gpg`が作成される
- 複合
  - `gpg --decypt {filename}.gpg`

### 公開鍵の共有
- エクスポート側
- gpg -o {送信用鍵ファイル名} -a --export {自分のメールアドレス}
  - 出力されるのはファイル
  - これをUSBなりなんなりで送る。
- インポート側
  - gpg --import {保存した鍵ファイル}
  - これを実行することでgpgでその鍵を認識させる
  - 利用にはその鍵が安全であると署名が必要
  - インポート側で署名
    - gpg -sign-key {mail_address}
  - gpg --list-keysで確認可能

### 公開鍵を使用して、秘密鍵の所有者だけが開封できる様にする
- `gpg -c`ではない
- 暗号化
  - `gpg e -a -r {recip} {filename}`
    - `-e` 暗号化（encrypt）
    - `-a ` ASCII 形式で出力（.asc ファイル）
    - `-r` <recipient> → 指定した受信者の公開鍵を使う
- 復号
  - `gpg {filename}`

### ファイルを署名する
- 署名ファイルを作成し、それをユーザに共有する手順となる
- 署名を作成
  - `gpg -o {署名ファイル}.sig --sign {対象ファイル}`
- 検証
  - `gpg --verify {sigファイル} {対象ファイル}`